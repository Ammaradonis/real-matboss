# Architecture Tradeoffs and Temporal Integrity Notes

MatBoss’s backend design prioritizes temporal correctness over optimistic UI assumptions, and this implementation follows that principle across the full booking lifecycle. The core tradeoff is deliberate: concurrency safety is enforced at both the application layer and the database layer, with PostgreSQL exclusion constraints as the final authority. Application checks (availability generation, buffer handling, blackout validation, minimum notice checks) improve user experience by filtering invalid options early, but they are not trusted as the final lock. At insertion time, the `bookings_no_overlaps` exclusion constraint on `tstzrange` ensures that even concurrent requests cannot produce a double booking for active statuses (`PENDING`, `CONFIRMED`). This dual-layer approach adds complexity, but it protects against race conditions that UI-only validation cannot prevent.

The second tradeoff is around schedule interpretation versus storage canonicalization. Slot computation uses provider timezone logic (`date-fns-tz`) while persistence remains UTC in PostgreSQL. This avoids drift, supports global clients, and preserves deterministic audit behavior in `booking_events`. The complexity is that every “local” rule must be transformed at generation time, and DST boundaries become a first-class concern. Tests now explicitly cover timezone-aware slot generation and DST windows, and blackout dates are enforced consistently using provider-local date projection. The model accepts this complexity because the product promise (sub-3-minute response for U.S. schools across timezones) requires reliable local-time semantics with global storage consistency.

For multi-tenant routing, provider public URL resolution now binds `tenantSlug + bookingUrl` together instead of resolving by booking URL alone. This avoids cross-tenant ambiguity and closes a real data isolation gap. The tradeoff is a slightly more complex query path (join with tenants), but the benefit is strict tenant scoping and safer public link behavior.

Qualification scoring and discovery pipeline behavior were kept in the booking flow, not split into a separate asynchronous domain service. This keeps first-response latency low and ensures admin analytics fields are immediately available after booking creation. The compromise is tighter coupling between booking and discovery-call context. Given MatBoss’s current architecture (single NestJS API with modular boundaries), this coupling is acceptable and still testable.

Admin analytics were expanded to include month-over-month metrics, weekly trend aggregates, lead funnel, state concentration, and budget/timeline/system breakdowns. The tradeoff here is query cost versus insight richness. These are aggregate queries over tenant-scoped data and should remain performant at current scale with proper indexing and bounded dashboard usage. If volumes grow significantly, these can move to materialized views or cached snapshots without changing API contracts.

Notification behavior is intentionally split: immediate SMTP send for test flows, persistent DB queue + cron retries for production delivery semantics. This introduces more moving parts but gives observability and retry control (`max_attempts=3`) needed for real-world SMTP unreliability.

Operationally, Vienna-based administration remains a feature rather than a constraint: seed defaults and admin settings support Vienna context, while provider buffers, notice windows, and UTC persistence preserve correct availability projection across ET/CT/MT/PT. This combination supports global operations without sacrificing U.S. local-time UX guarantees.
